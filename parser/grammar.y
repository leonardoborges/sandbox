class Parser


# Declare tokens produced by the lexer
token FUNC IF ELSE
token RETURN
token NUMBER STRING
token IDENTIFIER IDENTIFIER_LPAREN
token NEWLINE
token EQUALS OP_OR

#precedence
prechigh
  nonassoc '++'
  left     '*' '/'
  left     '+' '-'  
  left     '>'  
  left     EQUALS  
  left     OP_OR    
  right    '='
  nonassoc RETURN
preclow


rule

  Root:
    /* nothing */                      { result = Nodes.new([]) }
  | Expressions                        { result = val[0] }
  ;
  
  # Any list of expressions, class or method body, seperated by line breaks.
  Expressions:
    Expression                         { result = Nodes.new(val) }
  | Expressions Terminator Expression  { result = val[0] << val[2] }
    # To ignore trailing line breaks
  | Expressions Terminator             { result = Nodes.new([val[0]]) }
  ;

  # All types of expressions in our language
  Expression:
    RETURN Expression                   { result = ReturnNode.new(val[0][1], val[1]); }
  | Literal
  | Call
  | Assign
  | Func
  | Conditional
  | Operation
  ;
  
  # All tokens that can terminate an expression
  Terminator:
    NEWLINE
  | ";"
  ;
  
  # All hard-coded values
  Literal:
    NUMBER                        { result = LiteralNode.new(val[0][1], val[0][0]); }
  | STRING                        { result = LiteralNode.new(val[0][1], val[0][0]) }
  ;
  
  # A method call
  Call:
  IDENTIFIER_LPAREN ArgList ")"    { result = CallNode.new(val[0][1], nil, val[0][0], val[1]) }
  | IDENTIFIER ArgList    { result = CallNode.new(val[0][1], nil, val[0][0], val[1]) }
    # receiver.method
  | Expression "." IDENTIFIER ArgList    { result = CallNode.new(val[2][1], val[0], val[2][0], val[3]) }
    # receiver.method(arguments)
  | Expression "."
      IDENTIFIER_LPAREN ArgList ")"  { result = CallNode.new(val[2][1], val[0], val[2][0], val[3]) }
  ;
  
  ArgList:
    /* nothing */                 { result = [] }
  | Expression                    { result = val }
  | ArgList "," Expression        { result = val[0] << val[2] }
  ;
  
  # Assignation to a variable or contant
  Assign:
    IDENTIFIER "=" Expression     { result = SetLocalNode.new(val[0][1], val[0][0], val[2]) }
  ;
  
  # Method definition
  Func:
    FUNC IDENTIFIER "{" Block "}"                      { result = FuncNode.new(val[0][1], val[1][0], [], val[3]) }
  | FUNC IDENTIFIER_LPAREN ParamList ")" "{" Block "}"    { result = FuncNode.new(val[0][1], val[1][0], val[2], val[5]) }
  | FUNC IDENTIFIER "(" ParamList ")" "{" Block "}"    { result = FuncNode.new(val[0][1], val[1][0], val[3], val[6]) }  
  ;  
  
  # If statements
  Conditional:
    IF Expression "{" Block "}"                      { result = IfNode.new(val[0][1], val[1], val[3], nil) }
  | IF Expression "{" Block "}" ELSE "{" Block "}"   { result = IfNode.new(val[0][1], val[1], val[3], val[7]) }
  ;
  
  Operation:
    Expression '+' Expression      { result = PlusNode.new(val[1][1], val[0], val[2]) }
  | Expression '-' Expression      { result = MinusNode.new(val[1][1], val[0], val[2]) }
  | Expression '*' Expression      { result = TimesNode.new(val[1][1], val[0], val[2]) }
  | Expression '>' Expression      { result = GtNode.new(val[1][1], val[0], val[2]) }
  | Expression EQUALS Expression   { result = EqualsNode.new(val[1][1], val[0], val[2]) }
  | Expression OP_OR Expression    { result = OrNode.new(val[1][1], val[0], val[2]) }
  | '(' Operation ')'              { result = val[1] }
  ;

  ParamList:
    /* nothing */                 { result = [] }
  | IDENTIFIER                    { result = [val[0][0]] }
  | ParamList "," IDENTIFIER      { result = val[0] << val[2][0] }
  ;
  
  Block:
    Terminator Expressions Terminator     { result = val[1] }
  ;  

end

---- header ----
#
# generated by racc
#
require File.expand_path(File.join(File.dirname(__FILE__), "../", "lexer", "lexer.rex.rb"))
require File.expand_path(File.join(File.dirname(__FILE__), "../", "ast", "nodes.rb"))
---- inner ----


def parse(code)
  @lexer = Lexer.new
  @lexer.scan_setup(code)
  @tokens = []
  while t = @lexer.next_token
    @tokens.push t
  end
  @tokens.reverse!
  do_parse
end

def next_token
  token = @tokens.pop
  return if !token
  get_ttoken(token, @tokens)
end

def get_ttoken(token, tokens)
  if (token.is_a? Array) && (token[0] == :IDENTIFIER)
    next_token = tokens.pop
    if(next_token && (next_token[0] == "("))
      return [:IDENTIFIER_LPAREN, token[1]]
    else
      tokens.push(next_token)
    end
  elsif (token[0] == :WHITESPACE)
    return get_ttoken(tokens.pop, tokens)
  end
  return token
end
